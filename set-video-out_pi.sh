The reviewerâ€™s feedback is technically impeccable. They identified two subtle but real risks that could cause issues if this script were run repeatedly on a "messy" system (one with manual edits or older configurations).

1. **Byte-Level Newline Check:** Using `od` (Octal Dump) is the only truly safe way to check for a trailing newline in Bash, because standard variable capture strips trailing whitespace. This prevents your `config.txt` from slowly growing a long tail of empty lines.
2. **Ambiguity Guard:** If a Pi somehow ends up with *two* active video driver lines (e.g., both `vc4-kms-v3d` and `vc4-fkms-v3d`), editing just one creates a "zombie" configuration. Aborting in that scenario is the correct safety behavior.

Here is the **Final, Fleet-Safe Version**. This is the script you should deploy.

### The Script (`set-video-out.sh`)

```bash
#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
HDMI_RES="640x480@60D"     # Safe Mode: Universal HDMI compatibility
ANALOG_RES="720x576@50ie"  # Analog Mode: PAL, Interlaced, Forced Enable

# --- Mode Selection ---
INPUT="${1:--hdmi}"
case "$INPUT" in
  -hdmi|--hdmi)     MODE="hdmi"   ;;
  -analog|--analog) MODE="analog" ;;
  *)
    echo "Usage: sudo $0 [-hdmi | -analog]" >&2
    exit 1
    ;;
esac

# Root Check
if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
  echo "ERROR: must be run as root. Use: sudo $0 $INPUT" >&2
  exit 1
fi

# --- Locate boot files (require BOTH config.txt and cmdline.txt) ---
# Trixie/Bookworm uses /boot/firmware; older images use /boot
BOOT_DIR=""
if [[ -f /boot/firmware/config.txt && -f /boot/firmware/cmdline.txt ]]; then
  BOOT_DIR="/boot/firmware"
elif [[ -f /boot/config.txt && -f /boot/cmdline.txt ]]; then
  BOOT_DIR="/boot"
else
  echo "ERROR: cannot find config.txt/cmdline.txt under /boot/firmware or /boot" >&2
  exit 1
fi

CONFIG_FILE="${BOOT_DIR}/config.txt"
CMDLINE_FILE="${BOOT_DIR}/cmdline.txt"

# --- Refuse to edit stub/dummy files ---
# Prevents editing the "DO NOT EDIT" shim found on some OS upgrades
if grep -q "DO NOT EDIT THIS FILE" "$CONFIG_FILE" 2>/dev/null; then
  echo "ERROR: $CONFIG_FILE looks like a stub file (contains 'DO NOT EDIT THIS FILE')." >&2
  echo "       You probably want /boot/firmware/config.txt instead." >&2
  exit 1
fi
if grep -q "DO NOT EDIT THIS FILE" "$CMDLINE_FILE" 2>/dev/null; then
  echo "ERROR: $CMDLINE_FILE looks like a stub file (contains 'DO NOT EDIT THIS FILE')." >&2
  echo "       You probably want /boot/firmware/cmdline.txt instead." >&2
  exit 1
fi

# --- Step 1: Backups ---
ts="$(date +%Y%m%d_%H%M%S)"
cp -a "$CONFIG_FILE"  "${CONFIG_FILE}.bak.${ts}"
cp -a "$CMDLINE_FILE" "${CMDLINE_FILE}.bak.${ts}"
echo ">> Backups created:"
echo "   ${CONFIG_FILE}.bak.${ts}"
echo "   ${CMDLINE_FILE}.bak.${ts}"

# --- Step 2: CONFIG.TXT (Managed block) ---
BEGIN_MARK="# >>> halcyon-video BEGIN"
END_MARK="# <<< halcyon-video END"

tmp_cfg="$(mktemp)"
tmp_cfg2="$(mktemp)"
trap 'rm -f "$tmp_cfg" "$tmp_cfg2" 2>/dev/null || true' EXIT

# Remove old managed block (idempotency)
awk -v b="$BEGIN_MARK" -v e="$END_MARK" '
  $0==b {skip=1; next}
  $0==e {skip=0; next}
  skip!=1 {print}
' "$CONFIG_FILE" > "$tmp_cfg"

# Ensure exactly one trailing newline separator using byte inspection
# (Standard bash checks fail here because variables strip trailing newlines)
if [[ -s "$tmp_cfg" ]]; then
  last_byte="$(tail -c 1 "$tmp_cfg" | od -An -t u1 | tr -d ' ')"
  if [[ "$last_byte" != "10" ]]; then
    printf "\n" >> "$tmp_cfg"
  fi
fi

# Append new managed block
{
  echo "$BEGIN_MARK"
  echo "# Managed by set-video-out.sh"
  echo "[all]"   # Force global scope (fixes Pi 3/Zero ignoring settings if [pi4] was active)

  # KMS: prevent firmware from injecting its own video= mode (autodetect)
  echo "disable_fw_kms_setup=1"

  if [[ "$MODE" == "hdmi" ]]; then
    echo "enable_tvout=0"
  else
    echo "enable_tvout=1"
  fi
  echo "$END_MARK"
} >> "$tmp_cfg"

# --- Safety Check: Refuse ambiguous overlay state ---
# If multiple active vc4-kms lines exist, we cannot safely automate the edit.
kms_count="$(
  awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*dtoverlay=vc4-(f)?kms-v3d/ {c++}
    END{print c+0}
  ' "$tmp_cfg"
)"
if [[ "$kms_count" -gt 1 ]]; then
  echo "ERROR: multiple active dtoverlay=vc4-(f)kms-v3d lines found ($kms_count). Refusing to proceed." >&2
  echo "       Please manually consolidate to a single vc4-kms-v3d line in config.txt first." >&2
  exit 1
fi

# --- Step 3: Handle KMS Overlay (toggle ,composite) ---
# Finds the active driver line and adds/removes ",composite"
awk -v mode="$MODE" '
  BEGIN { found=0 }
  /^[[:space:]]*#/ { print; next }

  # Match both KMS and Fake-KMS (just in case)
  /^[[:space:]]*dtoverlay=vc4-(f)?kms-v3d/ {
    found=1
    line=$0

    # Remove composite param anywhere it appears
    gsub(/,composite(=[^,[:space:]]+)?/, "", line)
    gsub(/,,+/, ",", line)
    sub(/,$/, "", line)

    if (mode=="analog") {
      # Add composite flag (preserving inline comments)
      if (line ~ /[[:space:]]#/) sub(/[[:space:]]#/, ",composite #", line)
      else line=line ",composite"
    }

    print line
    next
  }

  { print }

  END {
    # If no overlay existed, create the standard KMS one
    if (found==0) {
      if (mode=="analog") print "dtoverlay=vc4-kms-v3d,composite"
      else               print "dtoverlay=vc4-kms-v3d"
    }
  }
' "$tmp_cfg" > "$tmp_cfg2"

mv "$tmp_cfg2" "$CONFIG_FILE"
echo ">> Updated: $CONFIG_FILE"

# --- Step 4: CMDLINE.TXT (Token parse) ---
# Safely rewrites video arguments while preserving root=, console=, etc.
cmdline_line="$(tr -d '\n' < "$CMDLINE_FILE" || true)"
IFS=' ' read -r -a toks <<< "$cmdline_line"

new_toks=()
for t in "${toks[@]}"; do
  case "$t" in
    video=HDMI-A-1:*|video=HDMI-A-2:*|video=Composite-1:*|vc4.tv_norm=* )
      ;;
    *)
      [[ -n "$t" ]] && new_toks+=("$t")
      ;;
  esac
done

if [[ "$MODE" == "hdmi" ]]; then
  echo ">> Setting Mode: HDMI (Force ${HDMI_RES})"
  # Forces both HDMI ports (harmless on single-port Pis)
  new_toks+=("video=HDMI-A-1:${HDMI_RES}" "video=HDMI-A-2:${HDMI_RES}")
else
  echo ">> Setting Mode: ANALOG (Force ${ANALOG_RES})"
  new_toks+=("vc4.tv_norm=PAL" "video=Composite-1:${ANALOG_RES}")
fi

printf '%s\n' "${new_toks[*]}" > "$CMDLINE_FILE"
echo ">> Updated: $CMDLINE_FILE"

echo "----------------------------------------------------"
echo "Success! Config applied for: $MODE"
echo "Reboot required to take effect:"
echo "  sudo reboot"
echo "----------------------------------------------------"

```