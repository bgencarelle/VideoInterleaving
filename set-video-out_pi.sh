#!/usr/bin/env bash
set -euo pipefail

# --- Configuration ---
HDMI_RES="640x480@60D"     # Safe Mode: universal HDMI compatibility
ANALOG_RES="720x576@50ie"  # PAL, interlaced, enable

# --- Mode Selection ---
INPUT="${1:--hdmi}"
case "$INPUT" in
  -hdmi|--hdmi)     MODE="hdmi"   ;;
  -analog|--analog) MODE="analog" ;;
  *)
    echo "Usage: sudo $0 [-hdmi | -analog]" >&2
    exit 1
    ;;
esac

# Root check
if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
  echo "ERROR: must be run as root. Use: sudo $0 $INPUT" >&2
  exit 1
fi

# --- Locate boot files (require BOTH config.txt and cmdline.txt) ---
BOOT_DIR=""
if [[ -f /boot/firmware/config.txt && -f /boot/firmware/cmdline.txt ]]; then
  BOOT_DIR="/boot/firmware"
elif [[ -f /boot/config.txt && -f /boot/cmdline.txt ]]; then
  BOOT_DIR="/boot"
else
  echo "ERROR: cannot find config.txt/cmdline.txt under /boot/firmware or /boot" >&2
  exit 1
fi

CONFIG_FILE="${BOOT_DIR}/config.txt"
CMDLINE_FILE="${BOOT_DIR}/cmdline.txt"

# Refuse to edit stub/dummy files
if grep -q "DO NOT EDIT THIS FILE" "$CONFIG_FILE" 2>/dev/null; then
  echo "ERROR: $CONFIG_FILE looks like a stub file (contains 'DO NOT EDIT THIS FILE')." >&2
  echo "       You probably want /boot/firmware/config.txt instead." >&2
  exit 1
fi
if grep -q "DO NOT EDIT THIS FILE" "$CMDLINE_FILE" 2>/dev/null; then
  echo "ERROR: $CMDLINE_FILE looks like a stub file (contains 'DO NOT EDIT THIS FILE')." >&2
  echo "       You probably want /boot/firmware/cmdline.txt instead." >&2
  exit 1
fi

# --- Backups ---
ts="$(date +%Y%m%d_%H%M%S)"
cp -a "$CONFIG_FILE"  "${CONFIG_FILE}.bak.${ts}"
cp -a "$CMDLINE_FILE" "${CMDLINE_FILE}.bak.${ts}"
echo ">> Backups created:"
echo "   ${CONFIG_FILE}.bak.${ts}"
echo "   ${CMDLINE_FILE}.bak.${ts}"

BEGIN_MARK="# >>> halcyon-video BEGIN"
END_MARK="# <<< halcyon-video END"

tmp_base="$(mktemp)"
tmp_cfg="$(mktemp)"
trap 'rm -f "$tmp_base" "$tmp_cfg" 2>/dev/null || true' EXIT

# --- Step 1: remove old managed block ---
awk -v b="$BEGIN_MARK" -v e="$END_MARK" '
  $0==b {skip=1; next}
  $0==e {skip=0; next}
  skip!=1 {print}
' "$CONFIG_FILE" > "$tmp_base"

# --- Step 2: find active vc4-(f)kms-v3d overlay lines ---
overlay_count="$(
  awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*dtoverlay=vc4-(f)?kms-v3d/ {c++}
    END{print c+0}
  ' "$tmp_base"
)"

if [[ "$overlay_count" -gt 1 ]]; then
  echo "ERROR: multiple active dtoverlay=vc4-(f)kms-v3d lines found ($overlay_count). Refusing." >&2
  echo "       Consolidate to a single active line first." >&2
  exit 1
fi

overlay_line="$(
  awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*dtoverlay=vc4-(f)?kms-v3d/ {print; exit}
  ' "$tmp_base"
)"

# --- Step 3: comment out the existing overlay line (if any) so we can manage it under [all] ---
awk '
  /^[[:space:]]*#/ {print; next}
  /^[[:space:]]*dtoverlay=vc4-(f)?kms-v3d/ {
    print "# disabled by set-video-out.sh (managed in halcyon block)"
    print "#" $0
    next
  }
  {print}
' "$tmp_base" > "$tmp_cfg"

# Ensure exactly one trailing newline separator using byte inspection
if [[ -s "$tmp_cfg" ]]; then
  last_byte="$(tail -c 1 "$tmp_cfg" | od -An -t u1 | tr -d ' ')"
  if [[ "$last_byte" != "10" ]]; then
    printf "\n" >> "$tmp_cfg"
  fi
fi

# --- Step 4: build the managed dtoverlay line (preserve params, toggle composite) ---
# Default overlay if none existed:
if [[ -z "${overlay_line:-}" ]]; then
  overlay_val="vc4-kms-v3d"
else
  # strip inline comment and whitespace
  no_comment="${overlay_line%%#*}"
  no_comment="${no_comment//$'\r'/}"
  no_comment="$(printf '%s' "$no_comment" | sed 's/[[:space:]]*$//')"
  overlay_val="${no_comment#dtoverlay=}"
fi

# Parse overlay name + params
overlay_val="${overlay_val//[[:space:]]/}"
IFS=',' read -r -a ov_parts <<< "$overlay_val"
ov_name="${ov_parts[0]}"

ov_params=()
if [[ "${#ov_parts[@]}" -gt 1 ]]; then
  for ((i=1; i<${#ov_parts[@]}; i++)); do
    p="${ov_parts[i]}"
    # drop composite toggles; we re-add deterministically
    case "$p" in
      composite|composite=*) ;;
      *) [[ -n "$p" ]] && ov_params+=("$p") ;;
    esac
  done
fi

if [[ "$MODE" == "analog" ]]; then
  ov_params+=("composite")
fi

managed_overlay="dtoverlay=${ov_name}"
if [[ "${#ov_params[@]}" -gt 0 ]]; then
  managed_overlay+=","
  managed_overlay+="$(IFS=','; echo "${ov_params[*]}")"
fi

# --- Step 5: append managed block ---
{
  echo "$BEGIN_MARK"
  echo "# Managed by set-video-out.sh"
  echo "[all]"

  # Prevent firmware from pushing its own chosen mode into cmdline (KMS should own it)
  echo "disable_fw_kms_setup=1"

  if [[ "$MODE" == "hdmi" ]]; then
    echo "enable_tvout=0"
  else
    echo "enable_tvout=1"
  fi

  # Ensure vc4 KMS overlay applies globally across Pi 0/3/4 mixed images
  echo "$managed_overlay"

  echo "$END_MARK"
} >> "$tmp_cfg"

mv "$tmp_cfg" "$CONFIG_FILE"
echo ">> Updated: $CONFIG_FILE"

# --- Step 6: CMDLINE.TXT token parse / rewrite ---
cmdline_line="$(tr -d '\n' < "$CMDLINE_FILE" || true)"
IFS=' ' read -r -a toks <<< "$cmdline_line"

new_toks=()
for t in "${toks[@]}"; do
  case "$t" in
    video=HDMI-A-1:*|video=HDMI-A-2:*|video=Composite-1:*|vc4.tv_norm=* )
      ;;
    *)
      [[ -n "$t" ]] && new_toks+=("$t")
      ;;
  esac
done

if [[ "$MODE" == "hdmi" ]]; then
  echo ">> Setting Mode: HDMI (Force ${HDMI_RES})"
  new_toks+=("video=HDMI-A-1:${HDMI_RES}" "video=HDMI-A-2:${HDMI_RES}")
else
  echo ">> Setting Mode: ANALOG (Force ${ANALOG_RES})"
  new_toks+=("vc4.tv_norm=PAL" "video=Composite-1:${ANALOG_RES}")
fi

printf '%s\n' "${new_toks[*]}" > "$CMDLINE_FILE"
echo ">> Updated: $CMDLINE_FILE"

echo "----------------------------------------------------"
echo "Success! Config applied for: $MODE"
echo "Reboot required:"
echo "  sudo reboot"
echo "----------------------------------------------------"
