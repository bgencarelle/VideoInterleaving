<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>VideoInterleaving Terminal</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="/static/xterm.css" />
  <link rel="stylesheet" href="/static/terminal.css" />

  <script src="/static/xterm.js" onerror="alert('CRITICAL ERROR: /static/xterm.js not found.')"></script>
</head>
<body>

  <div id="terminal-stage">
    <div id="terminal"></div>
  </div>

  <script>
    const WS_PORT = 2324;

    // --- 1. CONFIGURATION ---
    // Python will replace these values. If Nginx serves this raw, it falls back to 80x24.
    // NOTE: The Nginx fix below is required for this to work on the web!
    const COLS = parseInt("{{ASCII_WIDTH}}") || 80;
    const ROWS = parseInt("{{ASCII_HEIGHT}}") || 24;

    // --- 2. SETUP TERMINAL ---
    if (typeof Terminal === 'undefined') {
        throw new Error("xterm.js library missing");
    }

    const term = new Terminal({
      cols: COLS,
      rows: ROWS,
      fontFamily: 'Courier New, monospace',
      fontSize: 14,
      lineHeight: 1.0,
      cursorBlink: false,
      disableStdin: true,
      theme: { background: '#000000', foreground: '#e6e6e6' },
      allowTransparency: false
    });

    term.open(document.getElementById('terminal'));

    // --- 3. ROBUST SCALING LOGIC ---
    function fitToScreen() {
      const termEl = document.getElementById('terminal');
      // The .xterm-screen element is created by xterm.js and holds the actual canvas/dom
      const screenEl = termEl.querySelector('.xterm-screen');

      if (!screenEl) return false;

      const srcW = screenEl.clientWidth;
      const srcH = screenEl.clientHeight;

      // If dimensions are 0, the CSS or Font hasn't loaded yet. Abort.
      if (srcW < 1 || srcH < 1) return false;

      const targetW = window.innerWidth;
      const targetH = window.innerHeight;

      // Scale to fit screen edges
      const scale = Math.min(targetW / srcW, targetH / srcH);

      termEl.style.transform = `scale(${scale})`;
      return true;
    }

    // A recursive safer fit that waits for valid dimensions
    function safeFit() {
        if (fitToScreen()) {
            console.log("Terminal scaled successfully.");
        } else {
            console.log("Waiting for layout...");
            requestAnimationFrame(safeFit);
        }
    }

    // --- 4. WEBSOCKET ---
    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
      let wsUrl;

      // LOGIC: Are we running on standard web ports (80/443)?
      if (location.port === "" || location.port === "80" || location.port === "443") {
          // PRODUCTION (Nginx): Use the routed tunnel
          wsUrl = protocol + location.hostname + "/ascii_ws/";
          console.log("Environment: Production (Nginx Proxy)");
      } else {
          // LOCAL (Port 1980): Connect directly to the WebSocket port
          wsUrl = protocol + location.hostname + ":" + WS_PORT;
          console.log("Environment: Local (Direct Port)");
      }

      const ws = new WebSocket(wsUrl);
      ws.binaryType = "arraybuffer";

      ws.onopen = () => {
        term.reset();
        // Trigger a re-fit on connection just in case
        setTimeout(fitToScreen, 50);
      };

      ws.onmessage = (ev) => {
        term.write(ev.data);
      };

      ws.onclose = () => {
        console.warn("Connection lost. Reconnecting in 2s...");
        setTimeout(connect, 2000);
      };

      ws.onerror = () => ws.close();
    }

    // --- STARTUP SEQUENCE ---
    window.addEventListener('resize', () => requestAnimationFrame(fitToScreen));

    // Wait for Fonts (Courier New) to be ready before doing math
    document.fonts.ready.then(() => {
        console.log("Fonts loaded.");
        connect();
        // Start checking for valid dimensions to trigger the first scale
        requestAnimationFrame(safeFit);
    });
  </script>

  <!-- HIDE MOUSE AFTER A COUPLE OF SECONDS OF INACTIVITY -->
  <script>
    (function () {
      let hideTimeout;

      function resetCursorTimer() {
        // show cursor immediately on activity
        document.body.classList.remove('hide-cursor');

        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
          document.body.classList.add('hide-cursor');
        }, 2000); // 2000 ms = 2 seconds
      }

      ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(eventName => {
        window.addEventListener(eventName, resetCursorTimer, { passive: true });
      });

      // start the initial timer
      resetCursorTimer();
    })();
  </script>
</body>
</html>
