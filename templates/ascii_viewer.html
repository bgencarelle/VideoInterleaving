<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VideoInterleaving Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/static/xterm.css"/>
    <link rel="stylesheet" href="/static/terminal.css"/>
    <script src="/static/xterm.js"></script>

    <style>
        /* [CRITICAL FIX] Force black background immediately to prevent white borders/flashes */
        html, body {
            background-color: #000000 !important;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        #terminal-stage {
            background-color: #000000 !important;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #terminal {
            background-color: #000000 !important;
        }
    </style>
</head>
<body>

<div id="terminal-stage">
    <div id="terminal"></div>
</div>

<script>
    const WS_PORT = parseInt("{{WEBSOCKET_PORT}}") || 2424;

    // --- SETTINGS ---
    const COLS = parseInt("{{ASCII_WIDTH}}") || 80;
    const ROWS = parseInt("{{ASCII_HEIGHT}}") || 24;
    const TARGET_PIXEL_RATIO = parseFloat("{{ASCII_FONT_RATIO}}") || 0.5;

    const IMAGE_ASPECT_RATIO = (COLS * TARGET_PIXEL_RATIO) / ROWS;

    if (typeof Terminal === 'undefined') throw new Error("xterm.js missing");

    // --- 1. MEASURE FONT ---
    function measureFont(fontFamily, fontSize) {
        const span = document.createElement('span');
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize + 'px';
        span.style.visibility = 'hidden';
        span.style.whiteSpace = 'nowrap';
        span.textContent = 'M'.repeat(20);
        document.body.appendChild(span);
        const w = span.getBoundingClientRect().width / 20;
        const h = span.getBoundingClientRect().height;
        document.body.removeChild(span);
        return {w, h};
    }

    // --- 2. INIT ---
    function initTerminal() {
        const FONT_SIZE = 12;
        const FONT_FAMILY = 'Unscii, monospace';

        const m = measureFont(FONT_FAMILY, FONT_SIZE);

        // Calculate line height from font ratio to match target pixel ratio
        let lh = m.w / (m.h * TARGET_PIXEL_RATIO);
        if (lh < 0.8) lh = 0.8;
        
        const cellW = m.w;
        const cellH = m.h * lh;
        const imageAspectRatio = IMAGE_ASPECT_RATIO;

        const term = new Terminal({
            cols: COLS, rows: ROWS,
            fontFamily: FONT_FAMILY,
            fontSize: FONT_SIZE,
            lineHeight: lh,
            letterSpacing: 0,
            cursorBlink: false, disableStdin: true,
            // Ensure theme background matches the page background
            theme: {background: '#000000', foreground: '#e6e6e6'},
            allowTransparency: false
        });

        term.open(document.getElementById('terminal'));

        setupFit(term, imageAspectRatio);
        connect(term);
    }

    // --- 3. FIT TO SCREEN ---
    function setupFit(term, imageAspectRatio) {
        const fitToScreen = () => {
            const termEl = document.getElementById('terminal');
            const screenEl = termEl.querySelector('.xterm-screen');
            const stageEl = document.getElementById('terminal-stage');

            if (!screenEl || screenEl.clientWidth < 1) return false;

            const srcW = screenEl.clientWidth;
            const srcH = screenEl.clientHeight;
            
            // Use the terminal-stage container dimensions (works for both standalone and iframe)
            const containerW = stageEl.clientWidth || window.innerWidth;
            const containerH = stageEl.clientHeight || window.innerHeight;

            let targetW;
            let targetH;
            const containerRatio = containerW / containerH;

            if (containerRatio > imageAspectRatio) {
                targetH = containerH;
                targetW = targetH * imageAspectRatio;
            } else {
                targetW = containerW;
                targetH = targetW / imageAspectRatio;
            }

            const scale = Math.min(targetW / srcW, targetH / srcH);
            termEl.style.transform = `scale(${scale})`;
            
            // Ensure terminal-stage centers properly
            stageEl.style.display = 'flex';
            stageEl.style.justifyContent = 'center';
            stageEl.style.alignItems = 'center';

            return true;
        };

        const safeFit = () => {
            if (!fitToScreen()) requestAnimationFrame(safeFit);
        };
        window.addEventListener('resize', () => requestAnimationFrame(fitToScreen));
        requestAnimationFrame(safeFit);
        term.fitFn = safeFit;
    }

    // --- 4. CONNECTION ---
    function connect(term) {
        const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = (location.port === "" || location.port === "80" || location.port === "443")
                ? protocol + location.hostname + "/ascii_ws/"
                : protocol + location.hostname + ":" + WS_PORT;

        const ws = new WebSocket(wsUrl);
        ws.binaryType = "arraybuffer";

        ws.onopen = () => {
            term.reset();
            setTimeout(term.fitFn, 50);
        };
        ws.onmessage = (ev) => term.write(ev.data);
        ws.onclose = () => setTimeout(() => connect(term), 1000);
        ws.onerror = () => ws.close();
    }

    document.fonts.load("16px Unscii").then(() => initTerminal()).catch(() => initTerminal());

    (function () {
        let t;

        function reset() {
            document.body.classList.remove('hide-cursor');
            clearTimeout(t);
            t = setTimeout(() => document.body.classList.add('hide-cursor'), 2000);
        }

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(e =>
                window.addEventListener(e, reset, {passive: true}));
        reset();
    })();
</script>
</body>
</html>
