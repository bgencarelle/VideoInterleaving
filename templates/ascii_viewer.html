<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>VideoInterleaving Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/static/xterm.css" />
    <link rel="stylesheet" href="/static/terminal.css" />
    <script src="/static/xterm.js"></script>

    <style>
        /* [CRITICAL FIX] Force black background immediately to prevent white borders/flashes */
        html,
        body {
            background-color: #000000 !important;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        #terminal-stage {
            background-color: #000000 !important;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            /* Position will be set dynamically: relative for iframe, fixed for standalone */
        }

        #terminal {
            background-color: #000000 !important;
            box-sizing: border-box;
        }
    </style>
</head>

<body>

    <div id="terminal-stage">
        <div id="terminal"></div>
    </div>

    <script>
        const WS_PORT = parseInt("{{WEBSOCKET_PORT}}") || 2424;

        // --- SETTINGS ---
        let COLS = parseInt("{{ASCII_WIDTH}}") || 80;
        let ROWS = parseInt("{{ASCII_HEIGHT}}") || 24;
        const TARGET_PIXEL_RATIO = parseFloat("{{ASCII_FONT_RATIO}}") || 0.5;

        // Calculate aspect ratio dynamically based on current dimensions
        function getImageAspectRatio() {
            return (COLS * TARGET_PIXEL_RATIO) / ROWS;
        }
        let IMAGE_ASPECT_RATIO = getImageAspectRatio();

        if (typeof Terminal === 'undefined') throw new Error("xterm.js missing");

        // --- 1. MEASURE FONT ---
        function measureFont(fontFamily, fontSize) {
            const span = document.createElement('span');
            span.style.fontFamily = fontFamily;
            span.style.fontSize = fontSize + 'px';
            span.style.visibility = 'hidden';
            span.style.whiteSpace = 'nowrap';
            span.textContent = 'M'.repeat(20);
            document.body.appendChild(span);
            const w = span.getBoundingClientRect().width / 20;
            const h = span.getBoundingClientRect().height;
            document.body.removeChild(span);
            return { w, h };
        }

        // --- 2. INIT ---
        // Store cell dimensions for use in setupFit
        let cellW, cellH;
        let term; // Store terminal instance globally for resize operations

        function initTerminal() {
            const FONT_SIZE = 12;
            const FONT_FAMILY = 'Unscii, monospace';

            const m = measureFont(FONT_FAMILY, FONT_SIZE);

            // Calculate line height from font ratio to match target pixel ratio
            let lh = m.w / (m.h * TARGET_PIXEL_RATIO);
            // Test with smaller line spacing (0.3) for tighter text display
            if (lh < 0.1) lh = 0.1;

            // Calculate cell dimensions from font measurements
            cellW = m.w;
            cellH = m.h * lh;

            // Set minimum character spacing for tighter text display
            const MIN_LETTER_SPACING = 1.0;

            term = new Terminal({
                cols: COLS, rows: ROWS,
                fontFamily: FONT_FAMILY,
                fontSize: FONT_SIZE,
                lineHeight: lh,
                letterSpacing: MIN_LETTER_SPACING,
                cursorBlink: false, disableStdin: true,
                // Ensure theme background matches the page background
                theme: { background: '#000000', foreground: '#e6e6e6' },
                allowTransparency: false
            });

            term.open(document.getElementById('terminal'));

            // Wait for terminal to be fully rendered before setting up scaling
            // This ensures cellW and cellH are accurate and the terminal is sized correctly
            setTimeout(() => {
                setupFit(term);
            }, 100);

            connect(term);
        }

        // Function to handle dimension changes
        function handleDimensionChange(newCols, newRows) {
            if (!term) return;

            // Update dimensions
            COLS = newCols;
            ROWS = newRows;
            IMAGE_ASPECT_RATIO = getImageAspectRatio();

            // Resize terminal
            term.resize(newCols, newRows);

            // Recalculate and apply scaling to maintain window size
            if (term.fitFn) {
                setTimeout(term.fitFn, 50);
            }
        }

        // --- 3. FIT TO SCREEN ---
        function setupFit(term) {
            // Detect iframe context
            const isInIframe = window.self !== window.top;

            const fitToScreen = () => {
                const termEl = document.getElementById('terminal');
                const screenEl = termEl.querySelector('.xterm-screen');
                const stageEl = document.getElementById('terminal-stage');

                if (!screenEl || screenEl.clientWidth < 1) return false;

                // Use iframe dimensions if embedded, otherwise use viewport
                // window.innerWidth/Height represent the iframe dimensions when in iframe context
                const containerW = window.innerWidth;
                const containerH = window.innerHeight;

                // Get actual rendered terminal dimensions
                const actualW = screenEl.clientWidth;
                const actualH = screenEl.clientHeight;

                // Ensure dimensions are valid
                if (actualW <= 0 || actualH <= 0 || containerW <= 0 || containerH <= 0) {
                    return false;
                }

                // Calculate the image aspect ratio (accounting for font pixel ratio)
                const imageAspectRatio = (COLS * TARGET_PIXEL_RATIO) / ROWS;
                const containerAspectRatio = containerW / containerH;

                // Calculate scale to fill the container
                let scaleX, scaleY;

                if (isInIframe) {
                    // [STRETCH-TO-FILL] In an iframe, we force the terminal to match the iframe exactly.
                    // This ensures pixel-perfect alignment with the video layer in the parent.
                    scaleX = containerW / actualW;
                    scaleY = containerH / actualH;
                } else {
                    // [UNIFORM] Standalone: keep the image aspect ratio
                    const scale = (containerAspectRatio > imageAspectRatio)
                        ? (containerH / actualH)
                        : (containerW / actualW);
                    scaleX = scale;
                    scaleY = scale;
                }

                // Ensure scale is valid
                if (scaleX <= 0 || !isFinite(scaleX) || scaleY <= 0 || !isFinite(scaleY)) {
                    return false;
                }

                // Set terminal element to its natural rendered size
                termEl.style.width = actualW + 'px';
                termEl.style.height = actualH + 'px';
                termEl.style.position = 'relative';
                termEl.style.margin = '0';
                termEl.style.display = 'block';
                termEl.style.flexShrink = '0';

                // Apply scaling transform
                termEl.style.transform = `scale(${scaleX}, ${scaleY})`;
                termEl.style.transformOrigin = 'center center';

                // Adjust terminal-stage positioning based on context
                stageEl.style.display = 'flex';
                stageEl.style.justifyContent = 'center';
                stageEl.style.alignItems = 'center';
                stageEl.style.overflow = 'hidden'; // Prevent scaled content from overflowing

                if (isInIframe) {
                    // In iframe: fill the iframe completely
                    // The iframe itself should be sized to match the image aspect ratio by the parent
                    document.documentElement.style.width = '100%';
                    document.documentElement.style.height = '100%';
                    document.body.style.width = '100%';
                    document.body.style.height = '100%';

                    // Stage fills the body
                    stageEl.style.width = '100%';
                    stageEl.style.height = '100%';
                    stageEl.style.position = 'relative';
                } else {
                    // Standalone: use fixed positioning to fill viewport
                    stageEl.style.width = '100vw';
                    stageEl.style.height = '100vh';
                    stageEl.style.position = 'fixed';
                    stageEl.style.top = '0';
                    stageEl.style.left = '0';
                }

                return true;
            };

            const safeFit = () => {
                if (!fitToScreen()) requestAnimationFrame(safeFit);
            };
            window.addEventListener('resize', () => requestAnimationFrame(fitToScreen));
            requestAnimationFrame(safeFit);
            term.fitFn = safeFit;
        }

        // --- 4. CONNECTION ---
        function connect(term) {
            const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = (location.port === "" || location.port === "80" || location.port === "443")
                ? protocol + location.hostname + "/ascii_ws/"
                : protocol + location.hostname + ":" + WS_PORT;

            const ws = new WebSocket(wsUrl);
            ws.binaryType = "arraybuffer";
            connectedWS = ws;

            ws.onopen = () => {
                term.reset();
                setTimeout(term.fitFn, 50);
            };
            ws.onmessage = (ev) => term.write(ev.data);
            ws.onclose = () => {
                connectedWS = null;
                setTimeout(() => connect(term), 1000);
            }
            ws.onerror = () => ws.close();
        }

        document.fonts.load("16px Unscii").then(() => initTerminal()).catch(() => initTerminal());

        (function () {
            let t;
            const wsRef = { current: null }; // Hacky ref to access WS from event listener if needed

            function reset() {
                document.body.classList.remove('hide-cursor');
                clearTimeout(t);
                t = setTimeout(() => document.body.classList.add('hide-cursor'), 2000);
            }

            ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(e =>
                window.addEventListener(e, reset, { passive: true }));
            reset();

            // Key Controls
            window.addEventListener('keydown', (e) => {
                if (!connectedWS || connectedWS.readyState !== WebSocket.OPEN) return;

                if (e.key === 't' || e.key === 'T') {
                    connectedWS.send("CMD_TOGGLE_TEST");
                } else if (e.key === ']') {
                    connectedWS.send("CMD_RATIO_INC");
                } else if (e.key === '[') {
                    connectedWS.send("CMD_RATIO_DEC");
                }
            });
        })();

        // Internal var to expose WS to key listener
        let connectedWS = null;
    </script>
</body>

</html>