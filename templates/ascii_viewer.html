<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>VideoInterleaving Terminal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="/static/xterm.css" />
  <link rel="stylesheet" href="/static/terminal.css" />
  <script src="/static/xterm.js"></script>
</head>
<body>

  <div id="terminal-stage">
    <div id="terminal"></div>
  </div>

  <script>
    const WS_PORT = 2324;

    // --- SETTINGS ---
    const COLS = parseInt("{{ASCII_WIDTH}}") || 80;
    const ROWS = parseInt("{{ASCII_HEIGHT}}") || 24;
    const TARGET_PIXEL_RATIO = parseFloat("{{ASCII_FONT_RATIO}}") || 0.5;

    // Ideal Ratio of the whole image
    const IMAGE_ASPECT_RATIO = (COLS * TARGET_PIXEL_RATIO) / ROWS;

    if (typeof Terminal === 'undefined') throw new Error("xterm.js missing");

    // --- 1. MEASURE FONT ---
    function measureFont(fontFamily, fontSize) {
        const span = document.createElement('span');
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize + 'px';
        span.style.visibility = 'hidden';
        span.style.whiteSpace = 'nowrap';
        span.textContent = 'M'.repeat(20);
        document.body.appendChild(span);
        const w = span.getBoundingClientRect().width / 20;
        const h = span.getBoundingClientRect().height;
        document.body.removeChild(span);
        return { w, h };
    }

    // --- 2. INIT ---
    function initTerminal() {
        const FONT_SIZE = 12;
        const FONT_FAMILY = 'Unscii, monospace';

        const m = measureFont(FONT_FAMILY, FONT_SIZE);

        // Solver: Create scanlines to match target ratio
        let lh = m.w / (m.h * TARGET_PIXEL_RATIO);
        if (lh < 0.8) lh = 0.8;

        console.log(`[Solver] LH: ${lh.toFixed(3)}`);

        const term = new Terminal({
            cols: COLS, rows: ROWS,
            fontFamily: FONT_FAMILY,
            fontSize: FONT_SIZE,
            lineHeight: lh,
            letterSpacing: 0,
            cursorBlink: false, disableStdin: true,
            // [CHANGED] Force Solid Black Background
            theme: { background: '#000000', foreground: '#e6e6e6' },
            // [CHANGED] Disable transparency for solid wiping
            allowTransparency: false
        });

        term.open(document.getElementById('terminal'));

        setupFit(term);
        connect(term);
    }

    // --- 3. FIT TO SCREEN (FIXED) ---
    function setupFit(term) {
        const fitToScreen = () => {
            const termEl = document.getElementById('terminal');
            const screenEl = termEl.querySelector('.xterm-screen');

            if (!screenEl || screenEl.clientWidth < 1) return false;

            const srcW = screenEl.clientWidth;
            const srcH = screenEl.clientHeight;

            const winW = window.innerWidth;
            const winH = window.innerHeight;

            // 1. Calculate Target Box (Perfect Aspect Ratio)
            let targetW, targetH;
            const windowRatio = winW / winH;

            if (windowRatio > IMAGE_ASPECT_RATIO) {
                targetH = winH;
                targetW = targetH * IMAGE_ASPECT_RATIO;
            } else {
                targetW = winW;
                targetH = targetW / IMAGE_ASPECT_RATIO;
            }

            // 2. Safety Margin (99% size)
            targetW *= 0.99;
            targetH *= 0.99;

            // 3. Calculate Scale
            const scaleX = targetW / srcW;
            const scaleY = targetH / srcH;

            // 4. Apply
            termEl.style.transform = `scale(${scaleX}, ${scaleY})`;

            return true;
        };

        const safeFit = () => { if (!fitToScreen()) requestAnimationFrame(safeFit); };
        window.addEventListener('resize', () => requestAnimationFrame(fitToScreen));
        requestAnimationFrame(safeFit);
        term.fitFn = safeFit;
    }

    // --- 4. CONNECTION ---
    function connect(term) {
        const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = (location.port === "" || location.port === "80" || location.port === "443")
            ? protocol + location.hostname + "/ascii_ws/"
            : protocol + location.hostname + ":" + WS_PORT;

        const ws = new WebSocket(wsUrl);
        ws.binaryType = "arraybuffer";

        ws.onopen = () => {
            term.reset();
            setTimeout(term.fitFn, 50);
        };
        ws.onmessage = (ev) => term.write(ev.data);
        ws.onclose = () => setTimeout(() => connect(term), 1000);
        ws.onerror = () => ws.close();
    }

    // --- BOOT ---
    document.fonts.load("16px Unscii").then(() => initTerminal()).catch(() => initTerminal());

    (function () {
      let t;
      function reset() {
        document.body.classList.remove('hide-cursor');
        clearTimeout(t);
        t = setTimeout(() => document.body.classList.add('hide-cursor'), 2000);
      }
      ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach(e =>
        window.addEventListener(e, reset, { passive: true }));
      reset();
    })();
  </script>
</body>
</html>