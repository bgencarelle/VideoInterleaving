<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Broadcast Stream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="dark">
  <link rel="stylesheet" href="/static/stream.css">
  <style>
    #waiting-room {
      position: fixed; inset: 0;
      background: rgba(0, 0, 0, 0.9);
      color: #0f0;
      display: none;
      flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 100;
      font-family: monospace;
    }
    #waiting-room.active { display: flex; }
    .status-box { padding: 20px; text-align: center; }
    .spinner { margin-top: 15px; width: 24px; height: 24px; border: 3px solid #0f0; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; display: inline-block; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="contain no-cursor rot0">

  <div id="waiting-room">
    <div class="status-box">
      <div style="font-size: 1.5em; font-weight: bold; margin-bottom:10px;">CONNECTING...</div>
      <div id="slot-counter" style="color:#888">-- / --</div>
      <div class="spinner"></div>
    </div>
  </div>

  <div class="stage">
    <img id="video" src="" alt="" draggable="false" onerror="handleDisconnect()">
  </div>

  <div class="ui" role="toolbar">
    <button id="fitToggle">Contain</button>
    <button id="rotateToggle">Rotate</button>
    <button id="fsToggle">Fullscreen</button>
  </div>

  <script>
    const img = document.getElementById("video");
    const waitingOverlay = document.getElementById("waiting-room");
    const slotCounter = document.getElementById("slot-counter");
    let pollingInterval = null;
    let isReconnecting = false;

    startStream();

    function startStream() {
      // Unique timestamp forces browser to open a new connection
      img.src = "/video_feed?t=" + Date.now();
      isReconnecting = false;
    }

    function handleDisconnect() {
      if (isReconnecting) return;
      isReconnecting = true;

      console.log("Stream lost. Attempting auto-reconnect...");
      waitingOverlay.classList.add("active");
      img.style.display = 'none';

      // Start checking server status immediately
      pollServer();
      if (!pollingInterval) pollingInterval = setInterval(pollServer, 1000);
    }

    function pollServer() {
      fetch('/stats')
        .then(r => {
            if (r.ok) return r.json();
            throw new Error("Server not ready");
        })
        .then(data => {
          slotCounter.innerText = `${data.current} / ${data.max}`;
          // If server is up and has space (or we just want to try)
          if (!data.full) {
            resume();
          }
        })
        .catch(() => {
           slotCounter.innerText = "Server Offline";
        });
    }

    function resume() {
      clearInterval(pollingInterval);
      pollingInterval = null;
      waitingOverlay.classList.remove("active");
      img.style.display = 'block';
      startStream();
    }

    // Auto-resume when page becomes visible (user returns to tab)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // Page became visible - resume stream if it's not already running
        if (!img.src || img.complete === false || img.naturalWidth === 0) {
          console.log("Page visible - resuming stream");
          resume();
        }
      }
    });

    // Auto-resume on page load/reload
    window.addEventListener('load', () => {
      // Ensure stream starts on page load
      if (!img.src) {
        startStream();
      }
    });

    // --- UI Logic ---
    const body = document.body;
    document.getElementById('fitToggle').onclick = () => {
      body.classList.toggle('cover'); body.classList.toggle('contain');
      document.getElementById('fitToggle').innerText = body.classList.contains('cover') ? 'Cover' : 'Contain';
    };

    const ROTS = ['rot0','rot90','rot180','rot270'];
    document.getElementById('rotateToggle').onclick = () => {
      let i = ROTS.findIndex(c => body.classList.contains(c));
      body.classList.remove(...ROTS);
      body.classList.add(ROTS[(i+1)%4]);
    };

    document.getElementById('fsToggle').onclick = () => {
      (!document.fullscreenElement) ? document.documentElement.requestFullscreen() : document.exitFullscreen();
    };

    if (window.matchMedia('(orientation: portrait)').matches) body.classList.replace('contain','cover');
  </script>
</body>
</html>