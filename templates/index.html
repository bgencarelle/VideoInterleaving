<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>VideoInterleaving Terminal</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

  <style>
    /* --- LAYOUT RESET --- */
    * { box-sizing: border-box; }

    body {
      margin: 0;
      background-color: #000;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }

    /* --- THE CONTAINER (The Screen) --- */
    /* This element is ALWAYS the size of the browser window */
    #terminal-stage {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0; left: 0;

      /* Flexbox forces the scaled terminal to float in the center */
      display: flex;
      justify-content: center;
      align-items: center;

      background: #000;
      overflow: hidden;
    }

    /* --- THE CONTENT (The Fixed Grid) --- */
    /* We do NOT set width/height here. xterm.js sets it based on COLS/ROWS.
       We just handle the scaling transformation. */
    #terminal {
      /* Origin center ensures it scales evenly from the middle */
      transform-origin: center center;
      will-change: transform;

      /* Block pointer events so user can't select text */
      pointer-events: none;

      /* Remove block gaps */
      line-height: 0;
    }

    /* --- VISUALS --- */
    .xterm-viewport, .xterm-screen {
        margin: 0 !important;
        padding: 0 !important;
        overflow: hidden !important;
    }

    .xterm-screen canvas {
      filter: contrast(1.15) brightness(1.2) drop-shadow(0 0 3px rgba(200, 255, 200, 0.4));
    }

    .crt-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 999;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
      background-size: 100% 4px;
      opacity: 0.5;
    }
  </style>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
</head>
<body>

  <div class="crt-overlay"></div>

  <div id="terminal-stage">
    <div id="terminal"></div>
  </div>

  <script>
    const WS_PORT = 2324;
    const COLS = parseInt("{{ASCII_WIDTH}}");
    const ROWS = parseInt("{{ASCII_HEIGHT}}");

    // 1. Initialize Fixed Grid
    const term = new Terminal({
      cols: COLS,
      rows: ROWS,
      fontFamily: '"Share Tech Mono", "Courier New", monospace',
      fontSize: 14,
      lineHeight: 1.0,
      cursorBlink: false,
      disableStdin: true,
      theme: { background: '#000000', foreground: '#e6e6e6' },
      allowTransparency: true,
      scrollback: 0
    });

    term.open(document.getElementById('terminal'));

    // 2. The "Object-Fit: Contain" Logic
    function fitToScreen() {
      const stage = document.getElementById('terminal-stage');
      const termEl = document.getElementById('terminal');
      const canvas = document.querySelector('.xterm-screen canvas');

      if (!canvas) {
          requestAnimationFrame(fitToScreen);
          return;
      }

      // Reset to measure true size
      termEl.style.transform = 'none';

      // A. Measure the Container (Window)
      const stageW = stage.clientWidth;
      const stageH = stage.clientHeight;

      // B. Measure the Content (The fixed text grid)
      // canvas.width is physical pixels; divide by ratio to get CSS pixels
      const contentW = canvas.width / window.devicePixelRatio;
      const contentH = canvas.height / window.devicePixelRatio;

      if (contentW === 0 || contentH === 0) return;

      // C. Calculate Scale
      const scaleX = stageW / contentW;
      const scaleY = stageH / contentH;

      // "Contain" means use the smaller scale so nothing is cut off
      const scale = Math.min(scaleX, scaleY);

      // D. Apply to the Inner Element
      termEl.style.transform = `scale(${scale})`;
    }

    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsUrl = protocol + location.hostname + ":" + WS_PORT;
      const socket