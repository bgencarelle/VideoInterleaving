<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Broadcast Stream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="dark">
  <link rel="stylesheet" href="/static/stream.css">
  <style>
    /* Overlay for the Waiting Room */
    #waiting-room {
      position: fixed; inset: 0;
      background: rgba(10, 10, 10, 0.95);
      color: #0f0;
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 100;
      font-family: monospace;
      text-align: center;
    }
    #waiting-room.active { display: flex; }
    .status-box { border: 1px solid #333; padding: 20px; border-radius: 8px; background: #000; }
    .count-large { font-size: 2em; font-weight: bold; margin: 10px 0; }
    .spinner { margin-top: 15px; width: 20px; height: 20px; border: 2px solid #0f0; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; display: inline-block; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="contain no-cursor rot0">

  <div id="waiting-room">
    <div class="status-box">
      <div>SYSTEM FULL</div>
      <div class="count-large" id="slot-counter">-- / --</div>
      <div>Waiting for a slot...</div>
      <div class="spinner"></div>
    </div>
  </div>

  <div class="stage">
    <img id="video" src="" alt="Connecting..." draggable="false" onerror="handleStreamError()">
  </div>

  <div class="ui" role="toolbar" aria-label="Viewer controls">
    <button id="fitToggle" aria-pressed="false">Contain</button>
    <button id="rotateToggle">Rotate</button>
    <button id="fsToggle">Fullscreen</button>
  </div>

  <script>
    const img = document.getElementById("video");
    const waitingOverlay = document.getElementById("waiting-room");
    const slotCounter = document.getElementById("slot-counter");
    let pollingInterval = null;

    // 1. Initial Load
    startStream();

    function startStream() {
      // Add timestamp to break cache
      img.src = "/video_feed?t=" + new Date().getTime();
    }

    // 2. Triggered if Server returns 503 (or connection dies)
    function handleStreamError() {
      console.log("Stream failed (503 or dropped). Entering waiting room...");
      enterWaitingRoom();
    }

    function enterWaitingRoom() {
      waitingOverlay.classList.add("active");
      img.style.display = 'none'; // Hide broken image icon

      // Start polling stats immediately
      pollStats();
      if (!pollingInterval) {
        pollingInterval = setInterval(pollStats, 2000); // Check every 2 seconds
      }
    }

    function pollStats() {
      fetch('/stats')
        .then(r => r.json())
        .then(data => {
          // Update the UI counter
          slotCounter.innerText = `${data.current} / ${data.max}`;

          // If a slot is free, try to reconnect!
          if (!data.full) {
            console.log("Slot found! Reconnecting...");
            leaveWaitingRoom();
          }
        })
        .catch(e => console.log("Stats poll error", e));
    }

    function leaveWaitingRoom() {
      clearInterval(pollingInterval);
      pollingInterval = null;
      waitingOverlay.classList.remove("active");
      img.style.display = 'block';
      startStream(); // Reload the image source
    }

    // --- Tab Wake Logic (Keep this) ---
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        // If we aren't already waiting, refresh the stream
        if (!waitingOverlay.classList.contains("active")) {
           startStream();
        }
      }
    });

    // --- Standard UI Logic ---
    const body = document.body;
    const fitBtn = document.getElementById('fitToggle');
    const rotBtn = document.getElementById('rotateToggle');
    const fsBtn  = document.getElementById('fsToggle');

    function toggleFit() {
      const isCover = body.classList.contains('cover');
      body.classList.toggle('cover', !isCover);
      body.classList.toggle('contain', isCover);
      fitBtn.textContent = !isCover ? 'Cover' : 'Contain';
    }
    fitBtn.addEventListener('click', toggleFit);

    const ROT_SEQUENCE = ['rot0','rot90','rot180','rot270'];
    rotBtn.addEventListener('click', () => {
      const idx = ROT_SEQUENCE.findIndex(c => body.classList.contains(c));
      body.classList.remove(...ROT_SEQUENCE);
      body.classList.add(ROT_SEQUENCE[(idx + 1) % 4]);
    });

    fsBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    });

    // Auto-fit on load
    if (window.matchMedia('(orientation: portrait)').matches) toggleFit();

  </script>
</body>
</html>